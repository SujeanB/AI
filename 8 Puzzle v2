'''
Created 2020 M10 14
Author: Group IDs?
'''

from copy import deepcopy
from queue import PriorityQueue
import random

size = 3


class puzzle8:

    def __init__(self): 
        self.goalState = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]
        self.moves = 0
        self.empty = [0, 0]
        self.currState = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]
        self.size = 3
        
    def generateRand(self):

        randNum = random.randint(0, 50)
        for i in range(randNum):
            self.slide()
            # self.print()
            # print()
        return
    
    def slide(self):

        numStates = 0
        if self.empty[0] == 0:
            numStates += 1
            if self.empty[1] == 0:
                numStates += 1
                possibleMoves = [[1, 0], [0, 1]]
            elif self.empty[1] == 1:
                numStates += 2
                possibleMoves = [[0, 0], [0, 2], [1, 1]]
            elif self.empty[1] == 2:
                numStates += 1
                possibleMoves = [[0, 1], [1, 2]]
        elif self.empty[0] == 1:
            numStates += 2
            if self.empty[1] == 0:
                numStates += 1
                possibleMoves = [[0, 0], [1, 1], [2, 0]]
            elif self.empty[1] == 1:
                numStates += 2
                possibleMoves = [[1, 0], [1, 2], [0, 1], [2, 1]]
            elif self.empty[1] == 2:
                numStates += 1
                possibleMoves = [[0, 2], [1, 1], [2, 2]]
        elif self.empty[0] == 2:
            numStates += 1
            if self.empty[1] == 0:
                numStates += 1
                possibleMoves = [[2, 1], [1, 0]]
            elif self.empty[1] == 1:
                numStates += 2
                possibleMoves = [[2, 0], [2, 2], [1, 1]]
            elif self.empty[1] == 2:
                numStates += 1
                possibleMoves = [[2, 1], [1, 2]]
        
        randNum = random.randint(0, numStates - 1)
        temp = possibleMoves[randNum]
        value = self.currState[temp[0]][temp[1]]
        temp2 = self.empty
        self.currState[temp2[0]][temp2[1]] = value
        self.currState[temp[0]][temp[1]] = 0 
        self.empty = possibleMoves[randNum]

        return
    
    def print(self):
        for i in range(len(self.currState)):
            for j in range(len(self.currState[0])):
                print(self.currState[i][j], end='\t')
            print()
        return

    
class puzzle15:

    def __init__(self): 
        self.goalState = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]
        self.moves = 0
        self.empty = [0, 0]
        self.currState = [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11], [12, 13, 14, 15]]
        
    def generateRand(self):
        
        # self.print()
        randNum = random.randint(0, 100)
        for i in range(randNum):
            self.slide()
            # self.print()
        
        return
    
    def slide(self):

        numStates = 0
        if self.empty[0] == 0:
            numStates += 1
            if self.empty[1] == 0:
                numStates += 1
                possibleMoves = [[0, 1], [1, 0]]
            elif self.empty[1] == 1:
                numStates += 2
                possibleMoves = [[0, 0], [0, 2], [1, 1]]
            elif self.empty[1] == 2:
                numStates += 2
                possibleMoves = [[0, 1], [0, 3], [1, 2]]
            elif self.empty[1] == 3:
                numStates += 1
                possibleMoves = [[0, 2], [1, 3]]
        elif self.empty[0] == 1:
            numStates += 2
            if self.empty[1] == 0:
                numStates += 1
                possibleMoves = [[0, 0], [1, 1], [2, 0]]
            elif self.empty[1] == 1:
                numStates += 2
                possibleMoves = [[0, 1], [1, 0], [1, 2], [2, 1]]
            elif self.empty[1] == 2:
                numStates += 2
                possibleMoves = [[0, 2], [1, 1], [1, 3], [2, 2]]
            elif self.empty[1] == 3:
                numStates += 1
                possibleMoves = [[0, 3], [1, 2], [2, 3]]
        elif self.empty[0] == 2:
            numStates += 2
            if self.empty[1] == 0:
                numStates += 1
                possibleMoves = [[1, 0], [2, 1], [3, 0]]
            elif self.empty[1] == 1:
                numStates += 2
                possibleMoves = [[1, 1], [2, 0], [2, 2], [3, 1]]
            elif self.empty[1] == 2:
                numStates += 2
                possibleMoves = [[1, 2], [2, 1], [2, 3], [3, 2]]
            elif self.empty[1] == 3:
                numStates += 1
                possibleMoves = [[1, 3], [2, 2], [3, 3]]
        elif self.empty[0] == 3:
            numStates += 1
            if self.empty[1] == 0:
                numStates += 1
                possibleMoves = [[2, 0], [3, 1]]
            elif self.empty[1] == 1:
                numStates += 2
                possibleMoves = [[2, 1], [3, 0], [3, 2]]
            elif self.empty[1] == 2:
                numStates += 1
                possibleMoves = [[2, 2], [3, 1], [3, 3]]
            elif self.empty[1] == 3:
                numStates += 1
                possibleMoves = [[2, 3], [3, 2]]
        
        randNum = random.randint(0, numStates - 1)
        temp = possibleMoves[randNum]
        value = self.currState[temp[0]][temp[1]]
        temp2 = self.empty
        self.currState[temp2[0]][temp2[1]] = value
        self.currState[temp[0]][temp[1]] = 0 
        self.empty = possibleMoves[randNum]

        return
    
    def print(self):
        
        '''
        for i in range(len(self.currState)):
            for j in range(len(self.currState[i])):
                print(self.currState[i][j])
                # if self.currState[i][j] < 10:
                #    print(" ")
        '''

        mx = len(max((str(sub[0]) for sub in self.currState), key=len))

        for row in self.currState:
            print("  ".join(["{:<{mx}}".format(ele, mx=mx) for ele in row]))
        print("\n")


class puzzle24:

    def __init__(self): 
        self.goalState = [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]]
        self.moves = 0
        self.empty = [0, 0]
        self.currState = [[0, 1, 2, 3, 4], [5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24]]
        
    def generateRand(self):
        
        # self.print()
        randNum = random.randint(0, 100)
        for i in range(randNum):
            self.slide()
        # self.print()
        
        return
    
    def slide(self):

        numStates = 0
        if self.empty[0] == 0:
            numStates += 1
            if self.empty[1] == 0:
                numStates += 1
                possibleMoves = [[0, 1], [1, 0]]
            elif self.empty[1] == 1:
                numStates += 2
                possibleMoves = [[0, 0], [0, 2], [1, 1]]
            elif self.empty[1] == 2:
                numStates += 2
                possibleMoves = [[0, 1], [0, 3], [1, 2]]
            elif self.empty[1] == 3:
                numStates += 2
                possibleMoves = [[0, 2], [0, 4], [1, 3]]
            elif self.empty[1] == 4:
                numStates += 1
                possibleMoves = [[0, 3], [1, 4]]
        elif self.empty[0] == 1:
            numStates += 2
            if self.empty[1] == 0:
                numStates += 1
                possibleMoves = [[0, 0], [1, 1], [2, 0]]
            elif self.empty[1] == 1:
                numStates += 2
                possibleMoves = [[0, 1], [1, 0], [1, 2], [2, 1]]
            elif self.empty[1] == 2:
                numStates += 2
                possibleMoves = [[0, 2], [1, 1], [1, 3], [2, 2]]
            elif self.empty[1] == 3:
                numStates += 2
                possibleMoves = [[0, 3], [1, 2], [1, 4], [2, 3]]
            elif self.empty[1] == 4:
                numStates += 1
                possibleMoves = [[0, 4], [1, 3], [2, 4]]
        elif self.empty[0] == 2:
            numStates += 2
            if self.empty[1] == 0:
                numStates += 1
                possibleMoves = [[1, 0], [2, 1], [3, 0]]
            elif self.empty[1] == 1:
                numStates += 2
                possibleMoves = [[1, 1], [2, 0], [2, 2], [3, 1]]
            elif self.empty[1] == 2:
                numStates += 2
                possibleMoves = [[1, 2], [2, 1], [2, 3], [3, 2]]
            elif self.empty[1] == 3:
                numStates += 2
                possibleMoves = [[1, 3], [2, 2], [2, 4], [3, 3]]
            elif self.empty[1] == 4:
                numStates += 1
                possibleMoves = [[1, 4], [2, 3], [3, 4]]
        elif self.empty[0] == 3:
            numStates += 2
            if self.empty[1] == 0:
                numStates += 1
                possibleMoves = [[2, 0], [3, 1], [4, 0]]
            elif self.empty[1] == 1:
                numStates += 2
                possibleMoves = [[2, 1], [3, 0], [3, 2], [4, 1]]
            elif self.empty[1] == 2:
                numStates += 2
                possibleMoves = [[2, 2], [3, 1], [3, 3], [4, 2]]
            elif self.empty[1] == 3:
                numStates += 2
                possibleMoves = [[2, 3], [3, 2], [3, 4], [4, 3]]
            elif self.empty[1] == 4:
                numStates += 1
                possibleMoves = [[2, 4], [3, 3], [4, 4]]
        elif self.empty[0] == 4:
            numStates += 1
            if self.empty[1] == 0:
                numStates += 1
                possibleMoves = [[3, 0], [4, 1]]
            elif self.empty[1] == 1:
                numStates += 2
                possibleMoves = [[3, 1], [4, 0], [4, 2]]
            elif self.empty[1] == 2:
                numStates += 1
                possibleMoves = [[3, 2], [4, 1], [4, 3]]
            elif self.empty[1] == 3:
                numStates += 1
                possibleMoves = [[3, 3], [4, 2], [4, 4]]
            elif self.empty[1] == 4:
                numStates += 1
                possibleMoves = [[3, 4], [4, 3]]
        
        randNum = random.randint(0, numStates - 1)
        temp = possibleMoves[randNum]
        value = self.currState[temp[0]][temp[1]]
        temp2 = self.empty
        self.currState[temp2[0]][temp2[1]] = value
        self.currState[temp[0]][temp[1]] = 0 
        self.empty = possibleMoves[randNum]

        return
    
    def print(self):
        
        '''
        for i in range(len(self.currState)):
            for j in range(len(self.currState[i])):
                print(self.currState[i][j])
                # if self.currState[i][j] < 10:
                #    print(" ")
        '''

        mx = len(max((str(sub[0]) for sub in self.currState), key=len))

        for row in self.currState:
            print("  ".join(["{:<{mx}}".format(ele, mx=mx) for ele in row]))
        print("\n")


class Node(object):

    def __init__(self, puzzle, direction, parent=None):
        self.puzzle = puzzle 
        self.direction = direction
        self.parent = parent
        
    """Special method,which makes it possible for the classes to be compared. Used for PQueue."""

    def __lt__(self, other): 
        return 0

    def empty(self):
        for i in range(size):
            for j in range(size):
                if self.puzzle[i][j] == 0:
                    return i, j
    
    def misplacedTiles(self):
        value = 0
        n = 0
        for i in range (len(self.puzzle)):
            for j in range (len(self.puzzle[i])):
                if self.puzzle[i][j] != n:
                    value += 1
                    n += 1
                elif self.puzzle[i][j] == n:
                    n += 1
        return value
    
    def manhattanDist(self):
        t = 0
        for i in range(size):
            for j in range(size):
                r = int(self.puzzle[i][j] / size)
                c = int(self.puzzle[i][j] % size)
                t += abs(i - r) + abs(j - c)
        return t

    def getChildren(self):
        emptySpace = self.empty()
        puzzle = self.puzzle 
        nodes = []
        if not emptySpace[0] - 1 < 0:  # check to see if the node can be shifted downwards
            puzzle_up = deepcopy(puzzle) 
            puzzle_up[emptySpace[0]][emptySpace[1]] = puzzle_up[emptySpace[0] - 1][emptySpace[1]] 
            puzzle_up[emptySpace[0] - 1][emptySpace[1]] = 0 
            puzzle_up_node = Node(puzzle_up, 'down', self) 
            nodes.append(puzzle_up_node)  # check to see if the node can be shifted upwards
        if emptySpace[0] + 1 < size:  
            puzzle_down = deepcopy(puzzle)
            puzzle_down[emptySpace[0]][emptySpace[1]] = puzzle_down[emptySpace[0] + 1][emptySpace[1]]  # puts a value of the node above to the place, where zero was.
            puzzle_down[emptySpace[0] + 1][emptySpace[1]] = 0 
            puzzle_down_node = Node(puzzle_down, 'up', self)
            nodes.append(puzzle_down_node)
        if not emptySpace[1] - 1 < 0:  # check to see if the node can be shifted to the right
            puzzle_left = deepcopy(puzzle)
            puzzle_left[emptySpace[0]][emptySpace[1]] = puzzle_left[emptySpace[0]][emptySpace[1] - 1]  # puts a value of the node above to the place, where zero was.
            puzzle_left[emptySpace[0]][emptySpace[1] - 1] = 0
            puzzle_left_node = Node(puzzle_left, 'right', self)
            nodes.append(puzzle_left_node)
        if emptySpace[1] + 1 < size:  # check to see if the node can be shifted to the left
            puzzle_right = deepcopy(puzzle)
            puzzle_right[emptySpace[0]][emptySpace[1]] = puzzle_right[emptySpace[0]][emptySpace[1] + 1]  # puts a value of the node above to the place, where zero was.
            puzzle_right[emptySpace[0]][emptySpace[1] + 1] = 0 
            puzzle_right_node = Node(puzzle_right, 'left', self)
            nodes.append(puzzle_right_node)
        
        return nodes

    def node_traceback(self):  # returns a list of objects.
        p = []
        p.append((self.direction, self.puzzle))
        n = self.parent
        while n.parent is not None:
            p.append((n.direction, n.puzzle))
            n = n.parent
        p.append((n.direction, n.puzzle))
        p.reverse()
        return p


def h1Algo(start_node):
    PQueue = PriorityQueue() 
    visited = []
    explored = 0
    display(start_node.puzzle)
    print()
    PQueue.put((start_node.misplacedTiles(), start_node)) 
    while not PQueue.empty():  
        h, n = PQueue.get() 
        if n.puzzle in visited:   
            continue
        if h == 0: 
            print('Testing h1...')
            print('The number of explored nodes:%d' % explored)
            print('The number of steps taken:', (len(n.node_traceback())) - 1)
            print('-------------------------------')
            # draw_path(n.node_traceback())
            # display(start_node.b)
            return
       
        visited.append(n.puzzle)
       
        explored += 1
       
        for nnode in n.getChildren(): 
            PQueue.put((nnode.misplacedTiles(), nnode))


def h2Algo(start_node):
    PQueue = PriorityQueue() 
    visited = []
    explored = 0
    PQueue.put((start_node.manhattanDist(), start_node)) 
    while not PQueue.empty():  
        h, n = PQueue.get() 
        if n.puzzle in visited:   
            continue
        if h == 0: 
            print('Testing h2...')
            print('The number of explored nodes:%d' % explored)
            print('The number of steps taken:', (len(n.node_traceback())) - 1)
            print()
            # draw_path(n.node_traceback())
            # display(start_node.b)
            return
       
        visited.append(n.puzzle)
       
        explored += 1
       
        for nnode in n.getChildren(): 
            PQueue.put((nnode.manhattanDist(), nnode))     


def display(board):
        
        mx = len(max((str(i[0]) for i in board), key=len))
        for row in board:
            print("  ".join(["{:<{mx}}".format(ele, mx=mx) for ele in row]))
        print("\n")

'''
---------------------------------------------------------
---------------         Testing      --------------------
---------------------------------------------------------
'''
'''
board = puzzle8()
size = 3

for i in range (0, 100):
    board.generateRand()
    initial_node = Node(board.currState, 'start')
    h1Algo(initial_node)
    h2Algo(initial_node)

'''
for i in range (0, 100):
    board = puzzle15()
    size = 4
    board.generateRand()
    initial_node = Node(board.currState, 'start')
    h1Algo(initial_node)
    h2Algo(initial_node)

'''
for i in range (0, 3):
    board = puzzle24()
    size = 5
    board.generateRand()
    initial_node = Node(board.currState, 'start')
    h1Algo(initial_node)
    h2Algo(initial_node)
'''
